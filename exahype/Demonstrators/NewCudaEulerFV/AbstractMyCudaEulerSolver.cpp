// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "AbstractMyCudaEulerSolver.h"
#include "kernels/finitevolumes/godunov/c/2d/godunov.cpph"
#include "kernels/finitevolumes/godunov/c/3d/godunov.cpph"
//#include "kernels/finitevolumes/godunov/c/2d/cuda_godunov.h"

extern "C" {
  double cudaSolutionUpdate(double* luh_new, const double* luh, 
                          int numberOfVariables, int basisSize,
                          double cflFactor, double dt_max_allowed,
                          const double cellSize[], int patchBegin,
                          int patchEnd, double dt);
}

#include "MyCudaEulerSolver.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

NewCudaEulerFV::MyCudaEulerSolver::MyCudaEulerSolver(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs):
  AbstractMyCudaEulerSolver::AbstractMyCudaEulerSolver(maximumMeshSize,timeStepping) {
  init(cmdlineargs);
}

NewCudaEulerFV::AbstractMyCudaEulerSolver::AbstractMyCudaEulerSolver(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping):
  exahype::solvers::FiniteVolumesSolver("MyCudaEulerSolver",NumberOfVariables,NumberOfParameters,PatchSize,
                                        1/* ghost layer width */,maximumMeshSize,timeStepping) {
}

double NewCudaEulerFV::AbstractMyCudaEulerSolver::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double maxAdmissibleDt = kernels::finitevolumes::godunov::c::stableTimeStepSize<MyCudaEulerSolver>(*static_cast<MyCudaEulerSolver*>(this),luh,tempEigenvalues,dx,getNumberOfVariables(),getNodesPerCoordinateAxis());
  return maxAdmissibleDt;
}

void NewCudaEulerFV::AbstractMyCudaEulerSolver::solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) {
  maxAdmissibleDt = kernels::finitevolumes::godunov::c::solutionUpdate<MyCudaEulerSolver>(*static_cast<MyCudaEulerSolver*>(this),luhNew,luh,tempStateSizedArrays,tempUnknowns,dx,dt,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void NewCudaEulerFV::AbstractMyCudaEulerSolver::solutionAdjustment(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) {
  kernels::finitevolumes::godunov::c::solutionAdjustment<MyCudaEulerSolver>(*static_cast<MyCudaEulerSolver*>(this),luh,center,dx,t,dt,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void NewCudaEulerFV::AbstractMyCudaEulerSolver::ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  kernels::finitevolumes::godunov::c::ghostLayerFilling(luh,luhNeighbour,neighbourPosition,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void NewCudaEulerFV::AbstractMyCudaEulerSolver::ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::godunov::c::ghostLayerFillingAtBoundary(luh,luhbnd,boundaryPosition,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void NewCudaEulerFV::AbstractMyCudaEulerSolver::boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::godunov::c::boundaryLayerExtraction(luhbnd,luh,boundaryPosition,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void NewCudaEulerFV::AbstractMyCudaEulerSolver::boundaryConditions(double* luhbndOutside,const double* const luhbndInside,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
  kernels::finitevolumes::godunov::c::boundaryConditions<MyCudaEulerSolver>(*static_cast<MyCudaEulerSolver*>(this),luhbndOutside,luhbndInside,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);
}
