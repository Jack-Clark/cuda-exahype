// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __MyCudaEulerSolver_Variables_CLASS_HEADER__
#define __MyCudaEulerSolver_Variables_CLASS_HEADER__

#include "MyCudaEulerSolver.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

class NewCudaEulerFV::MyCudaEulerSolver::ReadOnlyVariables {
  private:
    const double* const _Q;
  public:
    static constexpr int SizeVariables  = 5;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 5+0;
    
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* const data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }
    

    double Q(int index) const {
      assertion(index >= 0 && index<5);
      return _Q[0+index];
    }

    tarch::la::Vector<5,double> Q() const {
      tarch::la::Vector<5,double> values;
      values=_Q[0],_Q[1],_Q[2],_Q[3],_Q[4];
      return values;
    }


};


class NewCudaEulerFV::MyCudaEulerSolver::Variables {
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = 5;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 5+0;
  
    Variables(double* Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }
    

    double Q(int index) const {
      assertion(index >= 0 && index<5);
      return _Q[0+index];
    }

    tarch::la::Vector<5,double> Q() const {
      tarch::la::Vector<5,double> values;
      values=_Q[0],_Q[1],_Q[2],_Q[3],_Q[4];
      return values;
    }



    double& Q(int index) { return _Q[0+index]; }

    void Q(const tarch::la::Vector<5,double>& values) {
      *(_Q+0)=values[0];
      *(_Q+1)=values[1];
      *(_Q+2)=values[2];
      *(_Q+3)=values[3];
      *(_Q+4)=values[4];
    }

    void Q(double Q0,double Q1,double Q2,double Q3,double Q4) {
      *(_Q+0)=Q0;
      *(_Q+1)=Q1;
      *(_Q+2)=Q2;
      *(_Q+3)=Q3;
      *(_Q+4)=Q4;
    }


};


class NewCudaEulerFV::MyCudaEulerSolver::Fluxes {
  private:
    double** _F;
  public:
    static constexpr int SizeVariables = 5; 
    static constexpr int Dimensions    = DIMENSIONS;
  
    Fluxes(double** F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }
    

    double Q(int row, int column) const {
      assertion(row >= 0 && row<5);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    tarch::la::Vector<DIMENSIONS,double> Q(int row) const {
      assertion(row >= 0 && row<5);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row]);
      #elif DIMENSIONS==3
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row],_F[2][0+row]);
      #endif
      return values;
    }

    tarch::la::Matrix<5,DIMENSIONS,double> Q() const {
      tarch::la::Matrix<5,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = _F[0][0],_F[1][0],
               _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3],
               _F[0][4],_F[1][4];
      #elif DIMENSIONS==3
      values = _F[0][0],_F[1][0],
               _F[0][1],_F[1][1],
               _F[0][2],_F[1][2],
               _F[0][3],_F[1][3],
               _F[0][4],_F[1][4];
      #endif
      return values;
    }



    double& Q(int row, int column) {
      assertion(row >= 0 && row<5);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    void Q(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<5);
      _F[0][0+row]=values[0];
      _F[1][0+row]=values[1];
      #if DIMENSIONS==2
      _F[2][0+row]=values[2];
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third vector element is ignored.*/
    void Q(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<5);
      _F[0][0+row]=values[0];
      _F[1][0+row]=values[1];
    }
    #endif

    void Q(const tarch::la::Matrix<5,DIMENSIONS,double>& values) {
      _F[0][0]=values(0,0);
      _F[0][1]=values(1,0);
      _F[0][2]=values(2,0);
      _F[0][3]=values(3,0);
      _F[0][4]=values(4,0);
      _F[1][0]=values(0,1);
      _F[1][1]=values(1,1);
      _F[1][2]=values(2,1);
      _F[1][3]=values(3,1);
      _F[1][4]=values(4,1);
      #if DIMENSIONS==3
      _F[2][0]=values(0,2);
      _F[2][1]=values(1,2);
      _F[2][2]=values(2,2);
      _F[2][3]=values(3,2);
      _F[2][4]=values(4,2);
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2.5D calculations. Third matrix column is ignored.*/
    void Q(const tarch::la::Matrix<5,3,double>& values) {
      _F[0][0]=values(0,0);
      _F[0][1]=values(1,0);
      _F[0][2]=values(2,0);
      _F[0][3]=values(3,0);
      _F[0][4]=values(4,0);
      _F[1][0]=values(0,1);
      _F[1][1]=values(1,1);
      _F[1][2]=values(2,1);
      _F[1][3]=values(3,1);
      _F[1][4]=values(4,1);
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third argument is ignored for the latter.*/
    void Q(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<5);
      _F[0][0+row]=v0;
      _F[1][0+row]=v1;
      #if DIMENSIONS==3
      _F[2][0+row]=v2;
      #endif
    }
    #if DIMENSIONS==2
    /** Setter for 2D calculations.*/
    void Q(int row, double v0,double v1) {
      assertion(row >= 0 && row<5);
      _F[0][0+row]=v0;
      _F[1][0+row]=v1;
    }
    #endif

    /** Setter for 3D and 2.5D calculations. Third column values are ignored for the latter.*/
    void Q(double v00, double v01, double v02,
           double v10, double v11, double v12,
           double v20, double v21, double v22,
           double v30, double v31, double v32,
           double v40, double v41, double v42) {
      _F[0][0]=v00;
      _F[0][1]=v10;
      _F[0][2]=v20;
      _F[0][3]=v30;
      _F[0][4]=v40;
      _F[1][0]=v01;
      _F[1][1]=v11;
      _F[1][2]=v21;
      _F[1][3]=v31;
      _F[1][4]=v41;
      #if DIMENSIONS==3
      _F[2][0]=v02;
      _F[2][1]=v12;
      _F[2][2]=v22;
      _F[2][3]=v32;
      _F[2][4]=v42;
      #endif
    }
    #if DIMENSIONS==2
    void Q(double v00, double v01,
           double v10, double v11,
           double v20, double v21,
           double v30, double v31,
           double v40, double v41) {
      _F[0][0]=v00;
      _F[0][1]=v10;
      _F[0][2]=v20;
      _F[0][3]=v30;
      _F[0][4]=v40;
      _F[1][0]=v01;
      _F[1][1]=v11;
      _F[1][2]=v21;
      _F[1][3]=v31;
      _F[1][4]=v41;
    }
    #endif


};




#endif