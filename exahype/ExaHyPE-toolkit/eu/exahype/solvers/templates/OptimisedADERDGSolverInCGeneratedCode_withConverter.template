// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#include "{{Solver}}.h"

#include "kernels/aderdg/optimised/Kernels.h"
#include "kernels/aderdg/generic/Kernels.h"
#include "kernels/aderdg/optimised/converter.h"


{{Project}}::{{Solver}}::{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}}):
  exahype::solvers::ADERDGSolver("{{Solver}}",nVar /* numberOfUnknowns */,nParams /* numberOfParameters */,order + 1  /* nodesPerCoordinateAxis */,maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
  init(cmdlineargs);
  // PS: If you miss access to user constants here,enable them in the toolkit
}

//TODO JMG remove when not needed anymore
void {{Project}}::{{Solver}}::fluxSplitted(const double* const Q, double* f, double* g{{fluxSplitted_h_signature}}) {
   double* F[{{fluxSplitted_dim}}];
   F[0] = f;
   F[1] = g;
   {{fluxSplitted_F_h}}
   flux(Q,F);
}

void {{Project}}::{{Solver}}::spaceTimePredictor(double* lQhbnd,double* lFhbnd,double** tempSpaceTimeUnknowns,double** tempSpaceTimeFluxUnknowns,double* tempUnknowns,double* tempFluxUnknowns,double* tempStateSizedVectors,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt, double* pointForceSources) {

  const bool useOptimised = false; //TODO JMG set to true when kernel fixed

{{BeforeSpaceTimePredictor}}
  
  
  if(useOptimised) {
    /*kernels::aderdg::optimised::picardLoop<fluxSplitted>( tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], luh, dx, dt );
    kernels::aderdg::optimised::predictor( tempUnknowns, tempFluxUnknowns, tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0] );
    kernels::aderdg::optimised::extrapolator( lQhbnd, lFhbnd, tempUnknowns, tempFluxUnknowns );*/
    kernels::aderdg::optimised::picardLoopNonlinear<flux>(luh, dt, dx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeUnknowns[2], tempSpaceTimeUnknowns[3],tempSpaceTimeFluxUnknowns[0], nullptr, nullptr, nullptr); //S, gradQ, BGradQ
    kernels::aderdg::optimised::predictorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], tempUnknowns, tempFluxUnknowns);
    kernels::aderdg::optimised::extrapolatorNonlinear(tempUnknowns, tempFluxUnknowns, lQhbnd, lFhbnd);
  } else {
    double* lQhi = new double[kernels::aderdg::optimised::converter::getQhiGenArraySize()];
    double* lFhi = new double[kernels::aderdg::optimised::converter::getFhiGenArraySize()];
    double* Qbnd = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    double* Fbnd = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    kernels::aderdg::optimised::converter::Qhi_optimised2generic(tempUnknowns, lQhi);
    kernels::aderdg::optimised::converter::Fhi_optimised2generic(tempFluxUnknowns, lFhi);
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(lQhbnd, Qbnd);
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(lFhbnd, Fbnd);
    
    kernels::aderdg::generic::c::spaceTimePredictorNonlinear<MyEulerSolver>(*this,Qbnd,Fbnd,tempSpaceTimeUnknowns,tempSpaceTimeFluxUnknowns,lQhi,lFhi,tempStateSizedVectors,luh,dx,dt,pointForceSources);
    
    kernels::aderdg::optimised::converter::Qhi_generic2optimised(lQhi, tempUnknowns);
    kernels::aderdg::optimised::converter::Fhi_generic2optimised(lFhi, tempFluxUnknowns);
    kernels::aderdg::optimised::converter::Bnd_generic2optimised(Qbnd, lQhbnd);
    kernels::aderdg::optimised::converter::Bnd_generic2optimised(Fbnd, lFhbnd);
    
    delete[] lQhi;
    delete[] lFhi;
    delete[] Qbnd;
    delete[] Fbnd;
  }
{{AfterSpaceTimePredictor}}
}



void {{Project}}::{{Solver}}::solutionUpdate(double* luh,const double* const lduh,const double dt) {
{{BeforeSolutionUpdate}}
  kernels::aderdg::optimised::solutionUpdate( luh, lduh, dt );
{{AfterSolutionUpdate}}
}



void {{Project}}::{{Solver}}::volumeIntegral(double* lduh,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& dx) {

  const bool useOptimised = true;

{{BeforeVolumeIntegral}}
  
  if(useOptimised) {
    kernels::aderdg::optimised::volumeIntegral( lduh, lFhi, dx );
  } else {
    double* lFhi_g = new double[kernels::aderdg::optimised::converter::getFhiGenArraySize()];
    kernels::aderdg::optimised::converter::Fhi_optimised2generic(lFhi, lFhi_g);
    
    kernels::aderdg::generic::c::volumeIntegralNonlinear(lduh,lFhi_g,dx,getNumberOfVariables(),getNumberOfParameters(),getNodesPerCoordinateAxis());
    
    delete[] lFhi_g;
  }
{{AfterVolumeIntegral}}
}



void {{Project}}::{{Solver}}::surfaceIntegral(double* lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& dx) {

 const bool useOptimised = false; //TODO JMG set to true when kernel fixed
 
{{BeforeSurfaceIntegral}}
   
  if(useOptimised) {
    kernels::aderdg::optimised::surfaceIntegral( lduh, lFhbnd, dx );
  } else {
    double* lFhbnd_g = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(lFhbnd, lFhbnd_g);
    
    kernels::aderdg::generic::c::surfaceIntegralNonlinear(lduh,lFhbnd_g,dx,getNumberOfVariables(),getNodesPerCoordinateAxis());
    
    delete[] lFhbnd_g;
  }
{{AfterSurfaceIntegral}}
}



void {{Project}}::{{Solver}}::riemannSolver(double* FL,double* FR,const double* const QL,const double* const QR,double* tempFaceUnknownsArray,double** tempStateSizedVectors,double** tempStateSizedSquareMatrices,const double dt,const int normalNonZeroIndex) {
  
  const bool useOptimised = true;
  
  assertion2(normalNonZeroIndex>=0,dt,normalNonZeroIndex);
  assertion2(normalNonZeroIndex<DIMENSIONS,dt,normalNonZeroIndex);
  
{{BeforeRiemannSolver}}
  
  
  if(useOptimised) {
    kernels::aderdg::optimised::riemannSolver<eigenvalues>( FL, FR, QL, QR, dt, normalNonZeroIndex );
  } else {
    double* FL_g = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    double* FR_g = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    double* QL_g = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    double* QR_g = new double[kernels::aderdg::optimised::converter::getBndGenArraySize()];
    
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(FL,FL_g);
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(FR,FR_g);
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(QL,QL_g);
    kernels::aderdg::optimised::converter::Bnd_optimised2generic(QR,QR_g);
    
    kernels::aderdg::generic::c::riemannSolverNonlinear<MyEulerSolver>(*this,FL_g,FR_g,QL_g,QR_g,tempFaceUnknownsArray,tempStateSizedVectors,tempStateSizedSquareMatrices,dt,normalNonZeroIndex);
    
    kernels::aderdg::optimised::converter::Bnd_generic2optimised(FL_g,FL);
    kernels::aderdg::optimised::converter::Bnd_generic2optimised(FR_g,FR);
    
    delete[] FL_g;  
    delete[] FR_g;  
    delete[] QL_g;  
    delete[] QR_g;
  }
{{AfterRiemannSolver}}
}



void {{Project}}::{{Solver}}::boundaryConditions(double* fluxOut,double* stateOut,const double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
{{BeforeBoundaryConditions}}
  kernels::aderdg::optimised::boundaryConditions<boundaryValues>(fluxOut, stateOut, fluxIn, stateIn, cellCentre, cellSize, t, dt, faceIndex, normalNonZero );
{{AfterBoundaryConditions}}
}



double {{Project}}::{{Solver}}::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {
{{BeforeStableTimeStepSize}}
  double d = kernels::aderdg::optimised::stableTimeStepSize<eigenvalues>( luh, dx );
{{AfterStableTimeStepSize}}
  return d;
}



void {{Project}}::{{Solver}}::solutionAdjustment(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,double dt) {
{{BeforeSolutionAdjustment}}
  kernels::aderdg::optimised::solutionAdjustment<adjustedSolutionValues>( luh, center, dx, t, dt );
{{AfterSolutionAdjustment}}
}



void {{Project}}::{{Solver}}::faceUnknownsProlongation(double* lQhbndFine,double* lFhbndFine,const double* lQhbndCoarse,const double* lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{{BeforeFaceUnknownsProlongation}}
  // kernels::aderdg::optimised::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, subfaceIndex, getNumberOfVariables(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterFaceUnknownsProlongation}}
}



void {{Project}}::{{Solver}}::faceUnknownsRestriction(double* lQhbndCoarse,double* lFhbndCoarse,const double* lQhbndFine,const double* lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{{BeforeFaceUnknownsRestriction}}
  // kernels::aderdg::optimised::faceUnknownsRestriction( lQhbndCoarse, lFhbndCoarse, lQhbndFine, lFhbndFine, coarseGridLevel, fineGridLevel, subfaceIndex, getNumberOfVariables(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterFaceUnknownsRestriction}}
}



void {{Project}}::{{Solver}}::volumeUnknownsProlongation(double* luhFine,const double* luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{{BeforeVolumeUnknownsProlongation}}
  // kernels::aderdg::optimised::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, subcellIndex, getNumberOfVariables(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterVolumeUnknownsProlongation}}
}



void {{Project}}::{{Solver}}::volumeUnknownsRestriction(double* luhCoarse,const double* luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{{BeforeVolumeUnknownsRestriction}}
  // kernels::aderdg::optimised::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, subcellIndex, getNumberOfVariables(), getNodesPerCoordinateAxis() ); //TODO JMG, uncomment in Toolkit when kernel implemented
{{AfterVolumeUnknownsRestriction}}
}
