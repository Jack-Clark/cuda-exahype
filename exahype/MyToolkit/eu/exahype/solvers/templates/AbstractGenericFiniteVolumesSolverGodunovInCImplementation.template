// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include "Abstract{{Solver}}.h"

#include "kernels/finitevolumes/godunov/c/2d/godunov.cpph"
#include "kernels/finitevolumes/godunov/c/3d/godunov.cpph"

#include "{{Solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

{{Project}}::{{Solver}}::{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}}):
  Abstract{{Solver}}::Abstract{{Solver}}(maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
  init(cmdlineargs);
}

{{Project}}::Abstract{{Solver}}::Abstract{{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping{{SolverConstructorSignatureExtension}}):
  exahype::solvers::FiniteVolumesSolver("{{Solver}}",NumberOfVariables,NumberOfParameters,PatchSize,
                                        1/* ghost layer width */,maximumMeshSize,timeStepping{{SolverConstructorArgumentExtension}}) {
}

double {{Project}}::Abstract{{Solver}}::stableTimeStepSize(const double* const luh,double* tempEigenvalues,const tarch::la::Vector<DIMENSIONS,double>& dx) {
  double maxAdmissibleDt = kernels::finitevolumes::godunov::c::stableTimeStepSize<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,tempEigenvalues,dx,getNumberOfVariables(),getNodesPerCoordinateAxis());
  return maxAdmissibleDt;
}

void {{Project}}::Abstract{{Solver}}::solutionUpdate(double* luhNew,const double* luh,double** tempStateSizedArrays,double** tempUnknowns,const tarch::la::Vector<DIMENSIONS,double>& dx,const double dt,double& maxAdmissibleDt) {
  maxAdmissibleDt = kernels::finitevolumes::godunov::c::solutionUpdate<{{Solver}}>(*static_cast<{{Solver}}*>(this),luhNew,luh,tempStateSizedArrays,tempUnknowns,dx,dt,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void {{Project}}::Abstract{{Solver}}::solutionAdjustment(double *luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) {
  kernels::finitevolumes::godunov::c::solutionAdjustment<{{Solver}}>(*static_cast<{{Solver}}*>(this),luh,center,dx,t,dt,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void {{Project}}::Abstract{{Solver}}::ghostLayerFilling(double* luh,const double* luhNeighbour,const tarch::la::Vector<DIMENSIONS,int>& neighbourPosition) {
  kernels::finitevolumes::godunov::c::ghostLayerFilling(luh,luhNeighbour,neighbourPosition,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void {{Project}}::Abstract{{Solver}}::ghostLayerFillingAtBoundary(double* luh,const double* luhbnd,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::godunov::c::ghostLayerFillingAtBoundary(luh,luhbnd,boundaryPosition,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void {{Project}}::Abstract{{Solver}}::boundaryLayerExtraction(double* luhbnd,const double* luh,const tarch::la::Vector<DIMENSIONS,int>& boundaryPosition) {
  kernels::finitevolumes::godunov::c::boundaryLayerExtraction(luhbnd,luh,boundaryPosition,getNumberOfVariables(),getNodesPerCoordinateAxis());
}

void {{Project}}::Abstract{{Solver}}::boundaryConditions(double* luhbndOutside,const double* const luhbndInside,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int normalNonZero) {
  kernels::finitevolumes::godunov::c::boundaryConditions<{{Solver}}>(*static_cast<{{Solver}}*>(this),luhbndOutside,luhbndInside,cellCentre,cellSize,t,dt,faceIndex,normalNonZero);
}
