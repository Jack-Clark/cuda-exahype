#ifndef __{{Solver}}_CLASS_HEADER__
#define __{{Solver}}_CLASS_HEADER__

// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <ostream>

#include "Abstract{{Solver}}.h"

{{ProfilerInclude}}
{{ParserInclude}}

namespace {{Project}}{
  class {{Solver}};
}

class {{Project}}::{{Solver}}: public {{Project}}::Abstract{{Solver}} {
  public:
    {{Solver}}(double maximumMeshSize,exahype::solvers::Solver::TimeStepping timeStepping,std::vector<std::string>& cmdlineargs{{SolverConstructorSignatureExtension}});

    void init(std::vector<std::string>& cmdlineargs{{SolverInitSignatureExtension}});

    exahype::solvers::Solver::RefinementControl refinementCriterion(const double* luh,const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,double t,const int level) override;
  
    bool hasToAdjustSolution(const tarch::la::Vector<DIMENSIONS,double>& center,const tarch::la::Vector<DIMENSIONS,double>& dx,const double t,const double dt) override;
    void eigenvalues(const double* const Q,const int normalNonZeroIndex,double* lambda);
    void flux(const double* const Q,double** F);
    void source(const double* const Q,double* S);
    void boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int normalNonZero,const double * const fluxIn,const double* const stateIn,double *fluxOut,double* stateOut);
    void adjustedSolutionValues(const double* const x,const double w,const double t,const double dt,double* Q);
    void ncp(const double* const Q,const double* const gradQ,double* BgradQ);
    void matrixb(const double* const Q,const int normalNonZero,double* Bn);
    bool isDummyKRequired() const override;
    void dummyK_Value(const double* const x,const double t,const double dt, double* forceVector, double* x0); //TODO KD
};

#endif // __{{Solver}}_CLASS_HEADER__