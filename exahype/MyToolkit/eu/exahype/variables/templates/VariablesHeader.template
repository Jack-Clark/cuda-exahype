// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __{{Solver}}_Variables_CLASS_HEADER__
#define __{{Solver}}_Variables_CLASS_HEADER__

#include "{{Solver}}.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

class {{Project}}::{{Solver}}::ReadOnlyVariables {
  private:
    const double* const _Q;
  public:
    static constexpr int SizeVariables  = {{NumberOfVariables}};
    static constexpr int SizeParameters = {{NumberOfParameters}};
    static constexpr int Size           = {{NumberOfVariables}}+{{NumberOfParameters}};
    
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* const data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }
    

{{VariablesGetters}}
};


class {{Project}}::{{Solver}}::Variables {
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = {{NumberOfVariables}};
    static constexpr int SizeParameters = {{NumberOfParameters}};
    static constexpr int Size           = {{NumberOfVariables}}+{{NumberOfParameters}};
  
    Variables(double* Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }
    

{{VariablesGetters}}

{{VariablesSetters}}
};


class {{Project}}::{{Solver}}::Fluxes {
  private:
    double** _F;
  public:
    static constexpr int SizeVariables = {{NumberOfVariables}}; 
    static constexpr int Dimensions    = DIMENSIONS;
  
    Fluxes(double** F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }
    

{{FluxesGetters}}

{{FluxesSetters}}
};


{{NamingSchemes}}

#endif